<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∫–ª—é—á–µ–π AES/RSA</title>
  <style>
    :root {
      --primary-color: #3498db;
      --primary-hover: #2980b9;
      --background: #f5f5f5;
      --card-bg: white;
      --text-color: #2c3e50;
    }
    
    @media (prefers-color-scheme: dark) {
      :root {
        --background: #121212;
        --card-bg: #1e1e1e;
        --text-color: #f5f5f5;
      }
    }
    
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: var(--background);
      color: var(--text-color);
      -webkit-text-size-adjust: 100%;
      touch-action: manipulation;
    }
    
    h1 {
      color: var(--primary-color);
      text-align: center;
      font-size: 1.8rem;
      margin-bottom: 1.5rem;
    }
    
    .section {
      background: var(--card-bg);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    
    h2 {
      font-size: 1.4rem;
      margin-top: 0;
      color: var(--primary-color);
    }
    
    h3 {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
    }
    
    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 12px 15px;
      border-radius: 8px;
      cursor: pointer;
      margin: 8px 0;
      width: 100%;
      font-size: 1rem;
      font-weight: 500;
      transition: background-color 0.2s;
      -webkit-appearance: none;
    }
    
    button:hover, button:active {
      background-color: var(--primary-hover);
    }
    
    .key-box {
      background: rgba(0,0,0,0.05);
      padding: 12px;
      border-radius: 8px;
      border: 1px dashed #ccc;
      word-break: break-all;
      margin: 12px 0;
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      line-height: 1.4;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    input[type="password"] {
      width: 100%;
      padding: 12px;
      margin: 8px 0;
      border-radius: 8px;
      border: 1px solid #ddd;
      font-size: 1rem;
      background: var(--card-bg);
      color: var(--text-color);
    }
    
    .copy-btn {
      background-color: #2ecc71;
      margin-top: -5px;
    }
    
    .copy-btn:hover, .copy-btn:active {
      background-color: #27ae60;
    }
    
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    @media (max-width: 600px) {
      body {
        padding: 15px;
      }
      
      .section {
        padding: 15px;
      }
      
      h1 {
        font-size: 1.5rem;
      }
      
      .key-box {
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <h1>üîë –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∫–ª—é—á–µ–π AES/RSA</h1>

  <!-- AES Section -->
  <div class="section">
    <h2>AES-256 –ö–ª—é—á</h2>
    <button id="generateAesKey">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å AES –∫–ª—é—á</button>
    <div id="aesKey" class="key-box">–ö–ª—é—á –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å...</div>
    <button id="saveAesKey">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å AES –∫–ª—é—á</button>
    <button id="copyAesKey" class="copy-btn">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å AES –∫–ª—é—á</button>
  </div>

  <!-- RSA Section -->
  <div class="section">
    <h2>RSA –ö–ª—é—á–∏</h2>
    <input type="password" id="rsaPassword" placeholder="–ü–∞—Ä–æ–ª—å –¥–ª—è –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ (–Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)">
    <button id="generateRsaKeys">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å RSA –∫–ª—é—á–∏</button>
    
    <h3>–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á:</h3>
    <div id="rsaPublicKey" class="key-box">–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å...</div>
    <button id="saveRsaPublicKey">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á</button>
    <button id="copyRsaPublicKey" class="copy-btn">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á</button>
    
    <h3>–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á:</h3>
    <div id="rsaPrivateKey" class="key-box">–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å...</div>
    <button id="saveRsaPrivateKey">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á</button>
    <button id="copyRsaPrivateKey" class="copy-btn">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á</button>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    // Toast notification
    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.style.opacity = 1;
      setTimeout(() => {
        toast.style.opacity = 0;
      }, 2000);
    }

    // Copy to clipboard function
    function copyToClipboard(text) {
      if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(() => {
          showToast('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞');
        }).catch(err => {
          console.error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å: ', err);
          fallbackCopy(text);
        });
      } else {
        fallbackCopy(text);
      }
    }

    function fallbackCopy(text) {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      document.body.appendChild(textarea);
      textarea.select();
      
      try {
        document.execCommand('copy');
        showToast('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞');
      } catch (err) {
        console.error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å: ', err);
        showToast('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è');
      }
      
      document.body.removeChild(textarea);
    }

    class RSALib {
      /**
       * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç RSA –∫–ª—é—á–µ–≤—É—é –ø–∞—Ä—É (2048 –±–∏—Ç)
       * @param {string} [password] - –ü–∞—Ä–æ–ª—å –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
       * @returns {Promise<{publicKey: string, privateKey: string}>}
       */
      static async generateKeyPair(password = null) {
        try {
          showToast('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π...');
          
          const keyPair = await crypto.subtle.generateKey(
            {
              name: 'RSA-OAEP',
              modulusLength: 2048,
              publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
              hash: 'SHA-256',
            },
            true,
            ['encrypt', 'decrypt']
          );

          const publicKey = await crypto.subtle.exportKey('spki', keyPair.publicKey);
          let privateKey = await crypto.subtle.exportKey('pkcs8', keyPair.privateKey);

          if (password) {
            const aesKey = await this._deriveAesKey(password);
            const iv = crypto.getRandomValues(new Uint8Array(16));
            const encryptedPrivateKey = await crypto.subtle.encrypt(
              { name: 'AES-CBC', iv },
              aesKey,
              privateKey
            );
            privateKey = this._arrayBufferToBase64(
              this._concatArrayBuffers(iv.buffer, encryptedPrivateKey)
            );
          } else {
            privateKey = this._arrayBufferToBase64(privateKey);
          }

          showToast('–ö–ª—é—á–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã');
          return {
            publicKey: this._arrayBufferToBase64(publicKey),
            privateKey: password ? `encrypted:${privateKey}` : privateKey,
          };
        } catch (error) {
          showToast('–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏');
          throw error;
        }
      }

      /**
       * –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–ª—é—á –≤ —Ñ–∞–π–ª
       * @param {string} key - –ö–ª—é—á –≤ Base64
       * @param {string} filename - –ò–º—è —Ñ–∞–π–ª–∞
       */
      static saveKey(key, filename) {
        try {
          // –î–ª—è iOS –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–æ–≤—ã–π Blob
          const blob = new Blob([key], { type: 'application/octet-stream' });
          const url = URL.createObjectURL(blob);
          
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.style.display = 'none';
          document.body.appendChild(a);
          
          // –î–ª—è iOS –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å click —Å–æ–±—ã—Ç–∏–µ
          const event = new MouseEvent('click', {
            view: window,
            bubbles: true,
            cancelable: true
          });
          
          a.dispatchEvent(event);
          
          // –û—á–∏—Å—Ç–∫–∞
          setTimeout(() => {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
          }, 100);
          
          showToast('–§–∞–π–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω');
        } catch (e) {
          showToast('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è');
          console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞:', e);
        }
      }

      // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
      static async _deriveAesKey(password) {
        const salt = new TextEncoder().encode('RSA-PRIVATE-KEY-SALT');
        const iterations = 100000;
        const keyMaterial = await crypto.subtle.importKey(
          'raw',
          new TextEncoder().encode(password),
          { name: 'PBKDF2' },
          false,
          ['deriveKey']
        );
        return crypto.subtle.deriveKey(
          {
            name: 'PBKDF2',
            salt,
            iterations,
            hash: 'SHA-256',
          },
          keyMaterial,
          { name: 'AES-CBC', length: 256 },
          false,
          ['encrypt', 'decrypt']
        );
      }

      static _concatArrayBuffers(buffer1, buffer2) {
        const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
        tmp.set(new Uint8Array(buffer1), 0);
        tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
        return tmp.buffer;
      }

      static _arrayBufferToBase64(buffer) {
        return btoa(String.fromCharCode(...new Uint8Array(buffer)));
      }
    }

    class AESLib {
      /**
       * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π AES-256 –∫–ª—é—á
       * @returns {Uint8Array} - 32-–±–∞–π—Ç–Ω—ã–π –∫–ª—é—á
       */
      static generateKey() {
        return crypto.getRandomValues(new Uint8Array(32));
      }

      /**
       * –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–ª—é—á –≤ —Ñ–∞–π–ª
       * @param {Uint8Array} key - –ö–ª—é—á –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
       * @param {string} [filename='aes-key.bin'] - –ò–º—è —Ñ–∞–π–ª–∞
       */
      static saveKey(key, filename = 'aes-key.bin') {
        try {
          const blob = new Blob([key], { type: 'application/octet-stream' });
          const url = URL.createObjectURL(blob);
          
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.style.display = 'none';
          document.body.appendChild(a);
          
          const event = new MouseEvent('click', {
            view: window,
            bubbles: true,
            cancelable: true
          });
          
          a.dispatchEvent(event);
          
          setTimeout(() => {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
          }, 100);
          
          showToast('–§–∞–π–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω');
        } catch (e) {
          showToast('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è');
          console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞:', e);
        }
      }
    }

    // –î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ HTML
    window.RSALib = RSALib;
    window.AESLib = AESLib;

    // ========== AES –õ–æ–≥–∏–∫–∞ ==========
    let aesKey = null;
    
    document.getElementById('generateAesKey').addEventListener('click', () => {
      try {
        aesKey = AESLib.generateKey();
        const keyBase64 = btoa(String.fromCharCode(...aesKey));
        document.getElementById('aesKey').textContent = `AES Key (Base64): ${keyBase64}`;
        showToast('AES –∫–ª—é—á —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω');
      } catch (e) {
        showToast('–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏');
        console.error(e);
      }
    });

    document.getElementById('saveAesKey').addEventListener('click', () => {
      if (!aesKey) {
        showToast('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–ª—é—á!');
        return;
      }
      AESLib.saveKey(aesKey, 'aes-key.bin');
    });

    document.getElementById('copyAesKey').addEventListener('click', () => {
      if (!aesKey) {
        showToast('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–ª—é—á!');
        return;
      }
      const keyBase64 = btoa(String.fromCharCode(...aesKey));
      copyToClipboard(keyBase64);
    });

    // ========== RSA –õ–æ–≥–∏–∫–∞ ==========
    let rsaKeys = null;
    
    document.getElementById('generateRsaKeys').addEventListener('click', async () => {
      const password = document.getElementById('rsaPassword').value || null;
      try {
        rsaKeys = await RSALib.generateKeyPair(password);
        document.getElementById('rsaPublicKey').textContent = 
          `–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á (Base64): ${rsaKeys.publicKey.substring(0, 100)}...`;
        document.getElementById('rsaPrivateKey').textContent = 
          `–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á: ${rsaKeys.privateKey.startsWith('encrypted:') ? '[–ó–ê–®–ò–§–†–û–í–ê–ù] ' : ''}${rsaKeys.privateKey.substring(0, 100)}...`;
      } catch (e) {
        showToast(`–û—à–∏–±–∫–∞: ${e.message}`);
        console.error(e);
      }
    });

    document.getElementById('saveRsaPublicKey').addEventListener('click', () => {
      if (!rsaKeys) {
        showToast('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–ª—é—á–∏!');
        return;
      }
      RSALib.saveKey(rsaKeys.publicKey, 'rsa-public.pem');
    });

    document.getElementById('copyRsaPublicKey').addEventListener('click', () => {
      if (!rsaKeys) {
        showToast('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–ª—é—á–∏!');
        return;
      }
      copyToClipboard(rsaKeys.publicKey);
    });

    document.getElementById('saveRsaPrivateKey').addEventListener('click', () => {
      if (!rsaKeys) {
        showToast('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–ª—é—á–∏!');
        return;
      }
      RSALib.saveKey(rsaKeys.privateKey, 'rsa-private.pem');
    });

    document.getElementById('copyRsaPrivateKey').addEventListener('click', () => {
      if (!rsaKeys) {
        showToast('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–ª—é—á–∏!');
        return;
      }
      copyToClipboard(rsaKeys.privateKey);
    });

    // –û—Ç–∫–ª—é—á–∞–µ–º –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∏ –¥–≤–æ–π–Ω–æ–º —Ç–∞–ø–µ (–¥–ª—è iOS)
    document.addEventListener('dblclick', (e) => {
      e.preventDefault();
    }, { passive: false });
  </script>
</body>
</html>